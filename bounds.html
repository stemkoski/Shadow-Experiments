<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<!-- blank favicon -->
    <link href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQEAYAAABPYyMiAAAABmJLR0T///////8JWPfcAAAACXBIWXMAAABIAAAASABGyWs+AAAAF0lEQVRIx2NgGAWjYBSMglEwCkbBSAcACBAAAeaR9cIAAAAASUVORK5CYII=" rel="icon" type="image/x-icon" />
	<title>three.js example</title>
	<style>
		body { margin: 0; }
	</style>
</head>

<body>

<script src="js/three.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/Stats.js"></script>
<script src="js/lil-gui.js"></script>

<script>

// standard scene elements

let scene = new THREE.Scene();
scene.background = new THREE.Color( 0xAACCFF );

let camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
camera.position.set(5,3,5);

let ambientLight = new THREE.AmbientLight(0x222222, 1);
scene.add(ambientLight);

/*
let d = 2.5;
let dirLight1 = new THREE.DirectionalLight(0x4444FF, 1);
dirLight1.position.set(d, d, 5);
dirLight1.target.position.set(d, d, 0);
dirLight1.castShadow = true;
dirLight1.shadow.mapSize = new THREE.Vector2(2048, 2048);
scene.add(dirLight1);
scene.add(dirLight1.target);
let helper1 = new THREE.DirectionalLightHelper(dirLight1);
scene.add(helper1);

let dirLight2 = new THREE.DirectionalLight(0xFF4444, 1);
dirLight2.position.set(5, d, d);
dirLight2.target.position.set(0, d, d);
dirLight2.castShadow = true;
dirLight2.shadow.mapSize = new THREE.Vector2(2048, 2048);
scene.add(dirLight2);
scene.add(dirLight2.target);
let helper2 = new THREE.DirectionalLightHelper(dirLight2);
scene.add(helper2);

let dirLight3 = new THREE.DirectionalLight(0x44FF44, 1);
dirLight3.position.set(d, 5, d);
dirLight3.target.position.set(d, 0, d);
dirLight3.castShadow = true;
dirLight3.shadow.mapSize = new THREE.Vector2(2048, 2048);
scene.add(dirLight3);
scene.add(dirLight3.target);
let helper3 = new THREE.DirectionalLightHelper(dirLight3);
scene.add(helper3);
*/

let renderer = new THREE.WebGLRenderer( {antialias: true} );
renderer.setSize( window.innerWidth, window.innerHeight );
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild( renderer.domElement );

var stats = new Stats();
stats.domElement.style.cssText = 'position:absolute;top:0px;left:0px;';
document.body.appendChild(stats.domElement);

let controls = new THREE.OrbitControls( camera, renderer.domElement );

window.addEventListener( 'resize', onWindowResize );

// custom scene elements

const axesHelper = new THREE.AxesHelper( 5 );
scene.add( axesHelper );

let gridSize = 12;
let gridDivisions = 10;
let gridCenterColor = 0xFF0000;
let gridLineColor = 0x000000;
let gridHelper = new THREE.GridHelper( gridSize, gridDivisions, gridCenterColor, gridLineColor );
// scene.add( gridHelper );

let floorGeometry = new THREE.PlaneGeometry(gridSize, gridSize);
let floorMaterial = new THREE.MeshBasicMaterial({ color: 0xDDFFDD, side: THREE.DoubleSide });
let floor = new THREE.Mesh(floorGeometry, floorMaterial);
floor.rotation.x = -Math.PI / 2;
scene.add(floor);
// shadow code
floor.receiveShadow = true;

/*
// cone parameters: radius, height, segments (~32 for circle)
let geometry = new THREE.ConeGeometry( 0.5, 1, 32 );
let material = new THREE.MeshLambertMaterial( { color: 0x888888 } );
let mesh = new THREE.Mesh( geometry, material );
// position refers to center
mesh.position.set(2, 1, 2);
mesh.castShadow = true;
scene.add( mesh );
*/

let wallGeoZ = new THREE.PlaneGeometry(6,6);
let wallZ = new THREE.Mesh( wallGeoZ, new THREE.MeshBasicMaterial({ color: 0xDDDDFF, side: THREE.DoubleSide, transparent:true, opacity:0.5 }) );
wallZ.position.set(3, 3, 0);
wallZ.receiveShadow = true;
scene.add(wallZ);

let wallGeoX = new THREE.PlaneGeometry(6,6);
let wallX = new THREE.Mesh( wallGeoX, new THREE.MeshBasicMaterial({ color: 0xFFDDDD, side: THREE.DoubleSide, transparent:true, opacity:0.5 }) );
wallX.position.set(0, 3, 3);
wallX.rotation.y = Math.PI/2;
wallX.receiveShadow = true;
scene.add(wallX);

let zPoint = new THREE.Mesh( 
	new THREE.SphereGeometry( 0.1 ),
	new THREE.MeshBasicMaterial( {color: 0x444444} )
);
scene.add(zPoint);
zPoint.position.set(0, 1, 0);


// set of points along XY-plane
let polygonPointArray = [
	new THREE.Vector3(3,4,0),
	new THREE.Vector3(1,3,0),
	new THREE.Vector3(2,1,0),
	new THREE.Vector3(3,2,0),
	new THREE.Vector3(4,1,0),
	new THREE.Vector3(5,3,0)
];

// set of points within YZ-plane
let polygonPointArray2 = [
	new THREE.Vector3(0,1,1),	
	new THREE.Vector3(0,4,2),	
	new THREE.Vector3(0,2,3),	
	new THREE.Vector3(0,3,4),	
	new THREE.Vector3(0,0,5)
];

function graphPolygon( pointArray, polygonColor=0x000000)
{
	// graph polygon points
	for (let i = 0; i < pointArray.length; i++)
	{
		let point = new THREE.Mesh( 
			new THREE.SphereGeometry( 0.02 ),
			new THREE.MeshBasicMaterial( {color: polygonColor} )
		);
		point.position.copy( pointArray[i] );
		scene.add(point);
	}

	// turn into a loop
	pointArray.push( pointArray[0] );

	// graph polygon lines
	let polygonLines = new THREE.Line( 
		new THREE.BufferGeometry().setFromPoints( pointArray ), 
		new THREE.LineBasicMaterial( {color: polygonColor} )
	);
	scene.add( polygonLines );
}

graphPolygon( polygonPointArray, 0x000088 );
graphPolygon( polygonPointArray2, 0x880000 );


let linePoints = [ new THREE.Vector3(0,0,0), new THREE.Vector3(0,1,0) ];
let ceilingLine = new THREE.Line(
	new THREE.BufferGeometry().setFromPoints( linePoints ), 
	new THREE.LineBasicMaterial( {color: 0x000044} )
);
scene.add( ceilingLine );

let ceilingLine2 = new THREE.Line(
	new THREE.BufferGeometry().setFromPoints( linePoints ), 
	new THREE.LineBasicMaterial( {color: 0x440000} )
);
scene.add( ceilingLine2 );

// params: line1, line2 = {slopeVec, pointVec}
// returns: {point1, point2}
//   where pointN is the point on lineN closest to the other line.
function closestPoints(line1, line2, debug=false)
{
	// line1: L1(t) = m1*t + p1
	// line2: L2(u) = m2*u + p2
	let m1 = line1.slopeVec, p1 = line1.pointVec;
	let m2 = line2.slopeVec, p2 = line2.pointVec;

	let n = new THREE.Vector3().crossVectors(m1, m2);
	// TODO: if n = <0,0,0> then lines are parallel, no unique solution exists - return null?

	let n1 = new THREE.Vector3().crossVectors(m1, n);
	let n2 = new THREE.Vector3().crossVectors(m2, n);

	let f1 = new THREE.Vector3().subVectors(p2, p1).dot( n2 ) / m1.dot(n2);
	let f2 = new THREE.Vector3().subVectors(p1, p2).dot( n1 ) / m2.dot(n1);

	let c1 = new THREE.Vector3().addVectors(p1, new THREE.Vector3().copy(m1).multiplyScalar(f1) );
	let c2 = new THREE.Vector3().addVectors(p2, new THREE.Vector3().copy(m2).multiplyScalar(f2) );

	return {point1: c1, point2: c2};
}

// params: line1, line2 = {slopeVec, pointVec}
// returns: point of intersection, if closest points are within epsilon of each other
function lineLineIntersection(line1, line2, epsilon=0.01, debug=false)
{
	if (debug)
	{
		console.log("lines")
		console.log(line1)
		console.log(line2)
	}

	let closest = closestPoints(line1, line2);

	// if lines are parallel, there is no unique pair of closest points
	//   and this computation is meaningless
	if ( closest == null )
		return null;

	let d = new THREE.Vector3().subVectors(closest.point1, closest.point2).length();

	// console.log(d)

	if ( d < epsilon )
	{
		let midpoint = new THREE.Vector3().addVectors(closest.point1, closest.point2).multiplyScalar(0.5);
		return midpoint;
	}
	else
	{
		return null;
	}
}

// calculate intersection (if any) of parametrically defined line segments
// line1, line2 = {slopeVec, pointVec, paramMin, paramMax}
function intersection(line1, line2, debug=false)
{
	if (debug)
	{
		console.log("lines")
		console.log(line1)
		console.log(line2)
	}

	// line1: L(t) = mt + p
	// line2: K(u) = nu + q
	let m = line1.slopeVec, p = line1.pointVec, tMin = line1.paramMin, tMax = line1.paramMax;
	let n = line2.slopeVec, q = line2.pointVec, uMin = line2.paramMin, uMax = line2.paramMax;
	// cramer's rule
	let detA = -m.x * n.y + m.y * n.x;

	if (debug)
		console.log("detA: " + detA)
	if (detA == 0)
		return null;
	
	let detA1b = -(q.x - p.x) * n.y + (q.y - p.y) * n.x;
	let t = detA1b / detA;

	if (debug)
		console.log( "t: " + t )

	if ( !(tMin <= t && t <= tMax) )
		return null;
	
	let detA2b = -m.x * (q.y - p.y) + m.y * (q.x - p.x);
	let u = detA2b / detA;

	if (debug)
		console.log( "u: " + u)

	if ( !(uMin <= u && u <= uMax))
		return null;

	let e = (m.z * t + p.z) - (n.z * u + q.z);
	if (!(e < 0.001))
		return null;

	return new THREE.Vector3( m.x * t + p.x, m.y * t + p.y, m.z * t + p.z)
}



let GUI = lil.GUI;
let gui = new GUI();

let guiParams = { 
	ceilingY: 1.0, 
	slopeAngle: 0.0, 
};

guiParams.changeParam = function()
{
	zPoint.position.set(0, guiParams.ceilingY, 0);
    let posAtt = ceilingLine.geometry.getAttribute('position');
	let posAtt2 = ceilingLine2.geometry.getAttribute('position');

	let p = new THREE.Vector3(0, guiParams.ceilingY, 0);

	/*
	// use if not recalculating automatically
	let m = new THREE.Vector3(Math.cos(guiParams.slopeAngle), Math.sin(guiParams.slopeAngle), 0);
	m.multiplyScalar( 6 );

	posAtt.setXYZ(0, p.x, p.y, p.z);
	posAtt.setXYZ(1, p.x + m.x, p.y + m.y, p.z + m.z);
	posAtt.needsUpdate = true;
	*/

	/*
	for (let i = 0; i < polygonPointArray.length - 1; i++)
	{
		let q = polygonPointArray[i];
		let q1 = polygonPointArray[i+1];
		let n = new THREE.Vector3().subVectors(q, q1);
		
		let intersectionPoint = intersection(
			{slopeVec:m, pointVec:p, paramMin:0, paramMax:1},
			{slopeVec:n, pointVec:q, paramMin:0, paramMax:1},
		);
		
		
		if (intersectionPoint != null)
		{
			console.log( "intersect segment " + i + " at " );
			console.log( intersectionPoint );
		}
		
	}
	*/

	let slopeAngle = findCeilingSlope();
	let slopeAngle2 = findCeilingSlope2();
	console.log(slopeAngle2)
	// console.log(slopeAngle);
	if (true)
	{
		let m = new THREE.Vector3(Math.cos(slopeAngle), Math.sin(slopeAngle), 0);
		m.multiplyScalar( 10 );

		posAtt.setXYZ(0, p.x, p.y, p.z);
		posAtt.setXYZ(1, p.x + m.x, p.y + m.y, p.z + m.z);
		posAtt.needsUpdate = true;

		let m2 = new THREE.Vector3(0, Math.sin(slopeAngle2), Math.cos(slopeAngle2));
		m2.multiplyScalar( 10 );

		posAtt2.setXYZ(0, p.x, p.y, p.z);
		posAtt2.setXYZ(1, p.x + m2.x, p.y + m2.y, p.z + m2.z);
		posAtt2.needsUpdate = true;

	}
}

function checkForIntersection(p, m, pointArray, debug=false)
{
	for (let i = 0; i < pointArray.length - 1; i++)
	{
		let q = pointArray[i];
		let q1 = pointArray[i+1];
		let n = new THREE.Vector3().subVectors(q, q1);
		
		let intersectionPoint = intersection(
			{slopeVec:m, pointVec:p, paramMin:0, paramMax:1},
			{slopeVec:n, pointVec:q, paramMin:0, paramMax:1},
			debug
		);
		
		// console.log(intersectionPoint)
		if (intersectionPoint != null)
			return intersectionPoint;
	}

	return null;
}

function findCeilingSlope()
{
	let delta = 0.01;
	for (let slopeAngle = 1.57; slopeAngle >= -1.57; slopeAngle -= delta)
	{
		let p = new THREE.Vector3(0, guiParams.ceilingY, 0);
		let m = new THREE.Vector3(Math.cos(slopeAngle), Math.sin(slopeAngle), 0);
		m.multiplyScalar( 10 );
		
		let intersectionData = checkForIntersection(p, m, polygonPointArray);
		if (intersectionData != null)
			return slopeAngle + delta;
	}

	return null;
}

function findCeilingSlope2()
{
	console.log("find slope 2")
	let delta = 0.01;
	for (let slopeAngle = 1.57; slopeAngle >= -1.57; slopeAngle -= delta)
	{
		let p = new THREE.Vector3(0, guiParams.ceilingY, 0);
		let m = new THREE.Vector3(0, Math.sin(slopeAngle), Math.cos(slopeAngle));
		m.multiplyScalar( 10 );
		console.log(m)
		let intersectionData = checkForIntersection(p, m, polygonPointArray2, false);
		if (intersectionData != null)
			return slopeAngle + delta;
	}

	return null;
}


// adding a slider
gui.add( guiParams, 'ceilingY', 0.0, 6.0, 0.01)
	  .name("ceiling Y")
	  .onChange( guiParams.changeParam );

gui.add( guiParams, 'slopeAngle', -1.57, 1.57, 0.01)
	  .name("slope angle")
	  .onChange( guiParams.changeParam );



function update()
{
	stats.update();

	/*
	mesh.rotation.x += 0.011;
	mesh.rotation.y += 0.013;
	mesh.rotation.z += 0.017;
	*/
}

function render()
{
	renderer.render( scene, camera );
}

function onWindowResize()
{
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize( window.innerWidth, window.innerHeight );
}

function loop() 
{
	requestAnimationFrame( loop );
	update();
	render();
};

loop();

</script>
</body>
</html>