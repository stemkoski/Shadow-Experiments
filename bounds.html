<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<!-- blank favicon -->
    <link href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQEAYAAABPYyMiAAAABmJLR0T///////8JWPfcAAAACXBIWXMAAABIAAAASABGyWs+AAAAF0lEQVRIx2NgGAWjYBSMglEwCkbBSAcACBAAAeaR9cIAAAAASUVORK5CYII=" rel="icon" type="image/x-icon" />
	<title>three.js example</title>
	<style>
		body { margin: 0; }
	</style>
</head>

<body>

<script src="js/three.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/Stats.js"></script>
<script src="js/lil-gui.js"></script>

<script>

// standard scene elements

let scene = new THREE.Scene();
scene.background = new THREE.Color( 0xAACCFF );

let camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
camera.position.set(5,3,5);

let ambientLight = new THREE.AmbientLight(0x222222, 1);
scene.add(ambientLight);

/*
let d = 2.5;
let dirLight1 = new THREE.DirectionalLight(0x4444FF, 1);
dirLight1.position.set(d, d, 5);
dirLight1.target.position.set(d, d, 0);
dirLight1.castShadow = true;
dirLight1.shadow.mapSize = new THREE.Vector2(2048, 2048);
scene.add(dirLight1);
scene.add(dirLight1.target);
let helper1 = new THREE.DirectionalLightHelper(dirLight1);
scene.add(helper1);

let dirLight2 = new THREE.DirectionalLight(0xFF4444, 1);
dirLight2.position.set(5, d, d);
dirLight2.target.position.set(0, d, d);
dirLight2.castShadow = true;
dirLight2.shadow.mapSize = new THREE.Vector2(2048, 2048);
scene.add(dirLight2);
scene.add(dirLight2.target);
let helper2 = new THREE.DirectionalLightHelper(dirLight2);
scene.add(helper2);

let dirLight3 = new THREE.DirectionalLight(0x44FF44, 1);
dirLight3.position.set(d, 5, d);
dirLight3.target.position.set(d, 0, d);
dirLight3.castShadow = true;
dirLight3.shadow.mapSize = new THREE.Vector2(2048, 2048);
scene.add(dirLight3);
scene.add(dirLight3.target);
let helper3 = new THREE.DirectionalLightHelper(dirLight3);
scene.add(helper3);
*/

let renderer = new THREE.WebGLRenderer( {antialias: true} );
renderer.setSize( window.innerWidth, window.innerHeight );
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild( renderer.domElement );

var stats = new Stats();
stats.domElement.style.cssText = 'position:absolute;top:0px;left:0px;';
document.body.appendChild(stats.domElement);

let controls = new THREE.OrbitControls( camera, renderer.domElement );

window.addEventListener( 'resize', onWindowResize );

// custom scene elements

const axesHelper = new THREE.AxesHelper( 5 );
scene.add( axesHelper );

let gridSize = 12;
let gridDivisions = 10;
let gridCenterColor = 0xFF0000;
let gridLineColor = 0x000000;
let gridHelper = new THREE.GridHelper( gridSize, gridDivisions, gridCenterColor, gridLineColor );
// scene.add( gridHelper );

let floorGeometry = new THREE.PlaneGeometry(gridSize, gridSize);
let floorMaterial = new THREE.MeshBasicMaterial({ color: 0xDDFFDD, side: THREE.DoubleSide });
let floor = new THREE.Mesh(floorGeometry, floorMaterial);
floor.rotation.x = -Math.PI / 2;
scene.add(floor);
// shadow code
floor.receiveShadow = true;

/*
// cone parameters: radius, height, segments (~32 for circle)
let geometry = new THREE.ConeGeometry( 0.5, 1, 32 );
let material = new THREE.MeshLambertMaterial( { color: 0x888888 } );
let mesh = new THREE.Mesh( geometry, material );
// position refers to center
mesh.position.set(2, 1, 2);
mesh.castShadow = true;
scene.add( mesh );
*/

let wallGeoZ = new THREE.PlaneGeometry(6,6);
let wallZ = new THREE.Mesh( wallGeoZ, new THREE.MeshBasicMaterial({ color: 0xDDDDFF, side: THREE.DoubleSide, transparent:true, opacity:0.5 }) );
wallZ.position.set(3, 3, 0);
wallZ.receiveShadow = true;
scene.add(wallZ);

let wallGeoX = new THREE.PlaneGeometry(6,6);
let wallX = new THREE.Mesh( wallGeoX, new THREE.MeshBasicMaterial({ color: 0xFFDDDD, side: THREE.DoubleSide, transparent:true, opacity:0.5 }) );
wallX.position.set(0, 3, 3);
wallX.rotation.y = Math.PI/2;
wallX.receiveShadow = true;
scene.add(wallX);

let zPoint = new THREE.Mesh( 
	new THREE.SphereGeometry( 0.1 ),
	new THREE.MeshBasicMaterial( {color: 0x444444} )
);
scene.add(zPoint);
zPoint.position.set(0, 1, 0);


// set of points along XY-plane
let polygonPointArray = [
	new THREE.Vector3(3,4,0),
	new THREE.Vector3(1,3,0),
	new THREE.Vector3(2,1,0),
	new THREE.Vector3(3,2,0),
	new THREE.Vector3(4,1,0),
	new THREE.Vector3(5,3,0)
];

for (let i = 0; i < polygonPointArray.length; i++)
{
	let point = new THREE.Mesh( 
		new THREE.SphereGeometry( 0.02 ),
		new THREE.MeshBasicMaterial( {color: 0x000044} )
	);
	point.position.copy( polygonPointArray[i] );
	scene.add(point);
}

// turn into a loop
polygonPointArray.push( polygonPointArray[0] );

let polygonLines = new THREE.Line( 
	new THREE.BufferGeometry().setFromPoints( polygonPointArray ), 
	new THREE.LineBasicMaterial( {color: 0x0000FF} )
);
scene.add( polygonLines );

let linePoints = [ new THREE.Vector3(0,0,0), new THREE.Vector3(0,1,0) ];
let ceilingLine = new THREE.Line(
	new THREE.BufferGeometry().setFromPoints( linePoints ), 
	new THREE.LineBasicMaterial( {color: 0x000000} )
);
scene.add( ceilingLine );

// calculate intersection (if any) of parametrically defined line segments
// line1, line2 = {slopeVec, pointVec, paramMin, paramMax}
function intersection(line1, line2)
{
	// line1: L(t) = mt + p
	// line2: K(u) = nu + q
	let m = line1.slopeVec, p = line1.pointVec, tMin = line1.paramMin, tMax = line1.paramMax;
	let n = line2.slopeVec, q = line2.pointVec, uMin = line2.paramMin, uMax = line2.paramMax;
	// cramer's rule
	let detA = -m.x * n.y + m.y * n.x;
	if (detA == 0)
		return null;
	
	let detA1b = -(q.x - p.x) * n.y + (q.y - p.y) * n.x;
	let t = detA1b / detA;
	// console.log( "t: " + t )
	if ( !(tMin <= t && t <= tMax) )
		return null;
	
	let detA2b = -m.x * (q.y - p.y) + m.y * (q.x - p.x);
	let u = detA2b / detA;
	// console.log( "u: " + u)
	if ( !(uMin <= u && u <= uMax))
		return null;

	let e = (m.z * t + p.z) - (n.z * u + q.z);
	if (!(e < 0.001))
		return null;

	return new THREE.Vector3( m.x * t + p.x, m.y * t + p.y, m.z * t + p.z)
}



let GUI = lil.GUI;
let gui = new GUI();

let guiParams = { 
	ceilingY: 1.0, 
	slopeAngle: 0.0, 
};

guiParams.changeParam = function()
{
	zPoint.position.set(0, guiParams.ceilingY, 0);
    let posAtt = ceilingLine.geometry.getAttribute('position');
	
	let p = new THREE.Vector3(0, guiParams.ceilingY, 0);
	let m = new THREE.Vector3(Math.cos(guiParams.slopeAngle), Math.sin(guiParams.slopeAngle), 0);
	m.multiplyScalar( 6 );

	posAtt.setXYZ(0, p.x, p.y, p.z);
	posAtt.setXYZ(1, p.x + m.x, p.y + m.y, p.z + m.z);
	posAtt.needsUpdate = true;

	/*
	for (let i = 0; i < polygonPointArray.length - 1; i++)
	{
		let q = polygonPointArray[i];
		let q1 = polygonPointArray[i+1];
		let n = new THREE.Vector3().subVectors(q, q1);
		
		let intersectionPoint = intersection(
			{slopeVec:m, pointVec:p, paramMin:0, paramMax:1},
			{slopeVec:n, pointVec:q, paramMin:0, paramMax:1},
		);
		
		
		if (intersectionPoint != null)
		{
			console.log( "intersect segment " + i + " at " );
			console.log( intersectionPoint );
		}
		
	}
	*/

	let slopeAngle = findCeilingSlope();
	console.log(slopeAngle);
	if (true)
	{
		let m = new THREE.Vector3(Math.cos(slopeAngle), Math.sin(slopeAngle), 0);
		m.multiplyScalar( 100 );

		posAtt.setXYZ(0, p.x, p.y, p.z);
		posAtt.setXYZ(1, p.x + m.x, p.y + m.y, p.z + m.z);
		posAtt.needsUpdate = true;
	}
}

function checkForIntersection(p, m)
{
	for (let i = 0; i < polygonPointArray.length - 1; i++)
	{
		let q = polygonPointArray[i];
		let q1 = polygonPointArray[i+1];
		let n = new THREE.Vector3().subVectors(q, q1);
		
		let intersectionPoint = intersection(
			{slopeVec:m, pointVec:p, paramMin:0, paramMax:1},
			{slopeVec:n, pointVec:q, paramMin:0, paramMax:1},
		);
		
		if (intersectionPoint != null)
			return intersectionPoint;
	}

	return null;
}

function findCeilingSlope()
{
	for (let slopeAngle = 1.57; slopeAngle >= -1.57; slopeAngle -= 0.01)
	{
		let p = new THREE.Vector3(0, guiParams.ceilingY, 0);
		let m = new THREE.Vector3(Math.cos(slopeAngle), Math.sin(slopeAngle), 0);
		m.multiplyScalar( 100 );
		
		let intersectionData = checkForIntersection(p, m);
		if (intersectionData != null)
			return slopeAngle + 0.01;
	}

	return null;
}


// adding a slider
gui.add( guiParams, 'ceilingY', -20.0, 6.0, 0.01)
	  .name("ceiling Y")
	  .onChange( guiParams.changeParam );

gui.add( guiParams, 'slopeAngle', -1.57, 1.57, 0.01)
	  .name("slope angle")
	  .onChange( guiParams.changeParam );



function update()
{
	stats.update();

	/*
	mesh.rotation.x += 0.011;
	mesh.rotation.y += 0.013;
	mesh.rotation.z += 0.017;
	*/
}

function render()
{
	renderer.render( scene, camera );
}

function onWindowResize()
{
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize( window.innerWidth, window.innerHeight );
}

function loop() 
{
	requestAnimationFrame( loop );
	update();
	render();
};

loop();

</script>
</body>
</html>