<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<!-- blank favicon -->
    <link href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQEAYAAABPYyMiAAAABmJLR0T///////8JWPfcAAAACXBIWXMAAABIAAAASABGyWs+AAAAF0lEQVRIx2NgGAWjYBSMglEwCkbBSAcACBAAAeaR9cIAAAAASUVORK5CYII=" rel="icon" type="image/x-icon" />
	<title>three.js example</title>
	<style>
		body { margin: 0; }
	</style>
</head>

<body>

<script src="js/three.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/csg-lib-new.js"></script>

<script>

// standard scene elements

let scene = new THREE.Scene();
scene.background = new THREE.Color( 0xAACCFF );

let camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
camera.position.set(0, 20, 10); 

let ambientLight = new THREE.AmbientLight(0x222222, 1);
scene.add(ambientLight);

let directionalLight = new THREE.DirectionalLight(0xDDDDDD, 1);
directionalLight.position.set(2.04, 4.05, 1.07);
directionalLight.target.position.set(0, 0, 0);
scene.add(directionalLight);
scene.add(directionalLight.target);

let renderer = new THREE.WebGLRenderer( {antialias: true} );
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );

// optional camera movement controls
let controls = new THREE.OrbitControls( camera, renderer.domElement );

// optional for window resizing
window.addEventListener( 'resize', onWindowResize );

// custom scene elements

let gridHelper = new THREE.GridHelper( 100, 100, 0x888888, 0xEEEEEE );
gridHelper.position.y = -0.1;
scene.add( gridHelper );

let floor = new THREE.Mesh(
	new THREE.PlaneGeometry(100, 100), 
	new THREE.MeshBasicMaterial({ transparent: true, opacity: 0.3 })
);
floor.rotation.x = -Math.PI / 2;
// scene.add(floor);

scene.add( new THREE.AxesHelper(5) );

function test()
{
	// points defining the polygon shape, listed in counterclockwise order
	let pointArray = [ 
		new THREE.Vector3( 12, 0, 2 ),
		new THREE.Vector3( 4, 0, 2 ),
		new THREE.Vector3( 4, 0, 8 ),
		new THREE.Vector3( 12, 0, 8 ),
		new THREE.Vector3( 8, 0, 6 ),
		new THREE.Vector3( 6, 0, 4 )
	] 

	// useful?
	let n = pointArray.length;
	let pointMeshArray = [];

	// mark each point location with a mesh ---------------------------------------

	for (let i = 0; i < n; i++)
	{
		// create a mesh centered at the origin
		// a mesh object is a combination of a geometry object and a material object
		let pointMesh = new THREE.Mesh(
			new THREE.OctahedronGeometry(0.1), 
			new THREE.MeshBasicMaterial({color:0x000000, wireframe:true})
		);

		// reposition the mesh at the position specified above
		pointMesh.position.copy( pointArray[i] );

		// add it to the scene
		scene.add(pointMesh);
	}

	// create a single line mesh connecting points --------------------------------

	// this is an array storing just the x, y, z coordinates of the points
	// each point is stored twice: once as an end point, once as a start point
	let positionXYZArray = [];

	// the corresponding colors for each point, stored as Red, Green, Blue values
	// intermediate points will have interpolated colors, forming a gradient
	let colorRGBarray = [];

	for (let i = 0; i < n; i++)
	{
		let P = pointArray[ i ];
		let Q = pointArray[ (i+1)%n ];
		positionXYZArray.push( P.x, P.y, P.z, Q.x, Q.y, Q.z );
		// add pink (1, 0.5, 0.5) and blue (0, 0, 1)
		colorRGBarray.push( 1, 0.5, 0.5, 0, 0, 1 );
	}
	
	let lineGeo = new THREE.BufferGeometry();

	lineGeo.setAttribute('position', 
			new THREE.BufferAttribute( new Float32Array(positionXYZArray), 3 ) );

	lineGeo.setAttribute('color', 
			new THREE.BufferAttribute( new Float32Array(colorRGBarray), 3 ) );

	let lineMat = new THREE.LineBasicMaterial( {vertexColors:true} );

	let lineMesh = new THREE.LineSegments( lineGeo, lineMat );

	scene.add(lineMesh);		

	// create a line/plane that splits the polygon into pieces ----------------------

	// calculate from three points A,B,C on plane in counterclockwise order
	//   order used to define normal and thus front of the plane
	let pointA = new THREE.Vector3( 7, 0, 0 );
	let pointB = new THREE.Vector3( 7, 1, 0 );
	let pointC = new THREE.Vector3( 7, 0, -1 );
	let vecAB = new THREE.Vector3().subVectors(pointB, pointA); 
	let vecAC = new THREE.Vector3().subVectors(pointC, pointA); 
 
	let pointMeshA = new THREE.Mesh(
		new THREE.OctahedronGeometry(0.1), 
		new THREE.MeshBasicMaterial({color:0x000000, wireframe:true})
	);
	pointMeshA.position.copy( pointA );
	scene.add(pointMeshA);
	
	let pointMeshB = new THREE.Mesh(
		new THREE.OctahedronGeometry(0.1), 
		new THREE.MeshBasicMaterial({color:0x000000, wireframe:true})
	);
	pointMeshB.position.copy( pointB );
	scene.add(pointMeshB);
	
	let pointMeshC = new THREE.Mesh(
		new THREE.OctahedronGeometry(0.1), 
		new THREE.MeshBasicMaterial({color:0x000000, wireframe:true})
	);
	pointMeshC.position.copy( pointC );
	scene.add(pointMeshC);


	// mark each point location with a mesh

	// render the corresponding plane -- as a large rectangle?

	// draw a vector indicating the direction of the front side

	// color the original points according to position of plane ---------------------

	// front: green, back: red, coplanar: yellow.
    // also store additional data in point variable: side = "FRONT" | "BACK" | "COPLANAR"
	

	// find any intersection of each segment with the plane ------------------------

	// there is a new intersection if and only if one endpoint is "FRONT", the other "BACK" 

	// intersections are automatically "COPLANAR"


	// ??? Should the new points be added to the original array? or a new array?




}

test();



function update()
{

}

function render()
{
	renderer.render( scene, camera );
}

function onWindowResize()
{
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize( window.innerWidth, window.innerHeight );
}

function loop() 
{
	requestAnimationFrame( loop );
	update();
	render();
};

loop();

</script>
</body>
</html>